# Лекция №5 (07/10/2025). Исключения, noexcept
## Коды ошибок
Откуда вообще берутся ошибки?

Например, аллокация памяти может зафейлиться, если вы запросили слишком много памяти.

Типичный подход для обработки ошибок:
- вводим перечисление возможных численных значений ошибок
```cpp
enum class Error {
    EOK = 0;
    ENOMEM = 1;
    EINVAl = 2;
    // etc
};
```
- вводим дополнительный канал для передачи значения кода ошибки

### Проблемы кодов ошибок
Коды ошибок это неудобно, небезопасно. Например, в `C` ошибки обрабатываются бесконечными `goto err`. Всегда можно забыть обработать какую-то ошибку.

Проблемы:
- легко пропустить обработку
- ветвление на каждую проверку
- теряется контекст
- предопределённые коды ошибок

### Коды ошибок в C++
- есть в стандартной библиотеке (`<system_error>`, `<charconv>`)
- не подходят в качестве общего механизма обработки ошибок

Но вот условно такой пример:
```cpp
auto& str = "1234asdj";
std::from_chars_result res = std::from_chars(std::begin(str), std::end(str), result);
```
Казалось бы, почему в C++17 появляется такая функция? Дело на самом деле в том, что `std::from_chars` скорее всего будет довольно часто вызываться в коде, а исключения будут сильно тормозить исполнение программы. Поэтому коды ошибок всё-таки тоже бывают полезны.

`try ... catch ...` классно работает с деструкторами, ибо после поимки исключения, все вложенные деструткоры автоматически вызываются.

Однако, бывают ситуации, когда деструкторы по внешним причинам не вызываются. Поэтому не стоит полгаться на это.

По умолчанию для всех деструкторов стоит ключевое слово `noexcept`. Вообще вприниципе деструкторам "запрещено" выбрасывать исключения.

Можно использовать такую вот конструкцию: `~Noisy() noexcept(false)`. То есть мы можем пометить функцию или деструктор тот же, как не `noexcept`.
