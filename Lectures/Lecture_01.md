# Лекция №1 (09/09/2025). Введение. Память
## Немного о курсе
- 14 лекций и 14 семинаров (приблизительно)
- 10 маленьких дз, 3 бдз, бонусные задачи
- формула оценки: `0,5*БДЗ + 0,3*МДЗ + 0,2*Коллоквиум + 0,1*Тесты + 0,1*Бонус`
  ```
  1) БДЗ - большие домашние задания (3 штуки)
     На 500-2000 строк вместе с тестированием, сложные концепты, дотошность в деталях, код-ревью по желанию
     Дедлайн 2-3 недели
     После дедлайна сразу 0 баллов
     Дедлайны не переносятся
     Защита перед ассистентами
  2) МДЗ - маленькие домашние задания (~10 штук); выдаются после *каждой* лекции; дедлайн воскресенье 23:59
     После дедлайна кол-во баллов убывает: 1 час - 99,17%; 2 часа - 98,3%; 5 часов - 95,92%; 12 часов - 90,5%;
     24 часа - 81,87%; ~6 суток - 30% до конца курса
     Защита перед ассистентами
  3) Защита:
     На защиту выносится несколько (может быть, 0) задач каждой обычной домашки + все БДЗ
     На защиту какое-то подмножество сдающих вызыввется
     Защита очная или онлайн с ассистентами
     Проваленная защита = 0 за мдз/бдз
  4) Коллоквиум - в конце курса
  5) Тесты - в конце семинара 2-3 вопроса в свободной форме
  6) Бонус - бонусные задачи
  ```
- любое списывание хотя бы одной задачи - заявление в УО
- коллоквиум по темам лекций (скорее всего в декабре)



## Цели курса
- как и почему применять современный C++
- пишем много кода, набиваем руку
- развиваем интуицию, не зубрим стандарт
- после курса можно спокойно идти писать код в прод
- курс основан на курсе по C++ из ШАДа, но перезачесть нельзя (слишком сильно уже разошлись, но пересечения есть)

### Инструменты
- проверяйте решения под санитайзерами
- учитесь пользоваться `gdb` (дебаггером)



## Переходим к лекции
### Память
- Память - самая главная абстракция C++
- Когда вы пишите код, вы постоянно должны понимать откуда и как идёт память
- С большой силой приходит большая ответственность: 80% всех уязвимостей и ошибок связаны с неправильной работой с памятью
- Как до 10-х годов люди писали код без санитайзеров в прод и при этом спокойно спали?

### Объекты
- создаются при помощи конструктора, разрушаются после завершения деструктора
- промежуток, когда объект живёт, называется `lifetime` или время жизни объекта
- доступ до объекта вне времени жизни - UB
- представление объекта - выровненный регион в памяти sizeof(object) байт
- переменная - объект или ссылка на него (другого не бывает)

### Что такое память?
- [страничное представление памяти](https://habr.com/ru/articles/345766/)
- каждая программа исполняется в изолированном адресном пространстве (`userspaces`)
- в C++ память это множество последовательных регионов байтов
- Байт - `char`, `sizeof(char) == 1`, `CHAR_BITS = ?` (сколько бит в байте обычно сложный вопрос)
- Но вообще согласно стандарту в байте *как минимум* 8 бит (но напрямую об этом нигде не написано, это исключительно некоторые умозаключения)
- Используйте или сишный `CHAR_BITS` или, если по плюсовому:
  ```cpp
  #include <limits>

  int main() {
    return std::numeric_limits<unsigned_char>::digits;
  }
  ```
- Объект прибит к последовательному участку памяти
- Копия или перемещение (`std::move`) = другой объект; объект не может переехать
- Существует несколько видов памяти

### Ручное управление жизнью объекта
- Не повторять дома (`placement new`):
  ```cpp
  char* buf = ...;
  new (buf) std::string ("Hello, world!");
  // мы по адресу buf размещаем в памяти объект, созданный при помощи std::string
  ...
  reinterpret_cast<std::string>(buf)->~basic_string();
  // мы руками создали объект, а значит руками должны его и разрушить
  // здесь показан ручной вызов деструктора
  // string - это alias для реального класса basic_string
  ```
  Здесь `new` называется `placement new`, размещающее `new`. Вы размещаете объект по конкретному адресу, который вы передали снаружи. То есть вы говорите компилятору: я выделил память под `buf`, получил указатель, инициализируй по этому адресу такой-то объект. То есть здесь по сути показали ручной вызов конструктора, для которого указали конкретное место в памяти, где надо создать объект. `new` вернёт указатель, который численно равен `char* buf`.

  Деструктор может иметь произвольную логику. А потому требуется вызов деструктора.

  Формально можно не вызывать деструктор для объектов следующего вида:
  ```cpp
  #include <type_traits>
  #include <string>

  int main() {
    static_assert(std::is_trivially_destructible_v<std::string>);
  }
  ```
  Объект для которого конструктор определён (даже если он пуст), не будет ялвяться тривиально разрушаемым.

  Если деструктор не определён или определён, как `~ClassName() = default` - то объект ялвяется тривиально разрушаемым.

  Главное заключение: если объект является тривиально разрушаемым, то деструктор для него можно не вызывать. Это очень классная оптимизация.

  То есть, например, чтобы разрушить вектор интов, вам не надо бежать по нему всему, а достаточно просто освободить под ним память.

  А почему нельзя повторять? Как минимум потому что вы должно чётко знать какого размера вам выделять буффер для объекта. Если ошибётесь, то попадёте в UB.

  А если выделить `char buf[1024]`, то тоже можно словить проблему. Ибо адрес должен быть выровнен по типу. Если он выровнен недостаточно - UB. Привет курс АКОСа ес чо.

  `static_assert()` - проверка на этапе компиляции

  `assert()` - проверка в runtime (то есть во время запуска), не надо её использовать

  Но жить можно, запросив выравнивание переменной: `alignas(alignof(std::string)) char buf[1024]`

  Например:
  ```cpp
  template <typename T>
  struct AlignedStorage {
    alignas(alignof(T)) char buf [sizeof(T)];
  };
  ```
  Структурка будет выровнена по T.
- А это тем более не повторять:
  ```cpp
  std::string kek("Hello, world!");
  (&kek)->~basic_string();
  // можно и так kek.~basic_string()
  new (&kek) std::string("Muhaha"); 
  ```
  Здесь происходит реинициализация объекта по известному адресу.
- Объект определяется своим storage и временем жизни этого storage
- Разные объекты могут переиспользовать одну память, но иметь разное время жизни:
  ```cpp
  std::vector<int> vec;
  vec.push_bask(0);  //vec[0] - object #1
  vec.pop_back();
  vec_push_bask(1);  //vec[0] - object #2
  ```
  По одному и тому же адресу живут разные объекты

### Виды памяти
- automatic storage duration (жаргон "на стеке")
- static storage duration (жаргон "глобальный", глобальные переменные)
- dynamic storage duration (жаргон "в куче", классический new)
- thread-local storage duration (C++11, после многопоточки)

*Динамическая память*:
- выделяется и освобождается руками
- объекты живут столько, сколько напишет программист
- low-level сырые `operator new`, `malloc`
- high-level типизированный `new` expression (`new int`, `new char[32]`)
- обёртки вроде `std::vector`, `std::string`
